# Sample code for computing a dotprod of two arrays
data:
    u64 a 0             # Memory address of array a
    u64 b 200000        # Memory address of array b
    u64 core_number 2   # Total number of cores
    u64 c 300000        # Memory to store f0

code:
    movui u0, 0         # Array index
    movui u1, 10000     # Number of array elements boundary
    movui u2, 8         # sizeof(f64)
    mulu  u1, u1, u2    # Array size in bytes (loop boundary)
    movfi f0, 0.0       # Accumulator

    movui u3, $a
    movui u4, $b
    movui u20, $c

    # Create two parallel regions

    parallel_on 0b11

    thread_on 0b11

    # Checking if it's core 1 or 2 (0 is for management core)

    get_core u31        # u31 = 1 if core 1 ; 2 if core 2
    movui u30 0
    cmpu u31, u30
    jne _case_core_two

    # Changing end of array for core 1

    movui u29 $core_number
    divu u1 u1 u29
    cmpu u1 u1
    je _start_work

_case_core_two:

    # Changing first element for core 2

    movui u29 $core_number
    divu u0 u1 u29

_start_work:

    movfi f1, 1.1     # Initializer for a
    movfi f2, 2.2     # Initializer for b

    # Initialize arrays

_init_loop:

    storef (u3, u0), f1
    storef (u4, u0), f2

    addu u0, u0, u2
    cmpu u0, u1
    jl _init_loop

    movui u0, 0

    # Compute dotprod
_dotprod_loop:

    loadf f1, (u3, u0)     # Load 8-byte DP FP value from a's memory
    loadf f2, (u4, u0)     # Load 8-byte DP FP value from b's memory

    fmaf f0, f1, f2        # f0 += f1 * f2

    addu u0, u0, u2        # u0 += 8 bytes
    cmpu u0, u1
    jl _dotprod_loop
    storef (u20, u31), f1

    thread_off

    parallel_off

    movui u0 0
    movui u1 1
    movui u20 $core_number
    movfi f1 0.0

_add_two:
    loadf f2 (u20, u0)
    addf f1, f1, f2
    addu u0, u0, u1
    cmpu u0, u20
    jl _add_two

    outf f0

    hlt
